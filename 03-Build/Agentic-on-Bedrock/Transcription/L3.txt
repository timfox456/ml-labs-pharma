In this lesson, my favorite lesson, you'll attach a code interpreter to your agent. This will give the agent the ability to perform accurate calculations by writing and running ephemeral Python code to support its generation. Let's take a look. And let's get started quickly. So I'm going to run this for ourselves, loading all of our libraries. And I'm going to create ourselves a bedrock agent client. So we're ready to go. Now, the agent that we have installed inside of this environment at the moment is the same as the one from the end of the last lesson. So we're going to update it here and we're going to call on Amazon Bedrock agent. And we're going to call on Update Action Group. Because we want to add some features, or one function in particular to this action group. Now, if you remember from setting up the action group in the first place, there are a lot of parameters to put in here. So I'm just going to paste them in in chunks and we can look through them as I'm pasting them in. But they should all be pretty familiar and similar to what we did last time. So we have the action group name, which is the same as it was before. We have an action group state here of enabled. We didn't actually pass that in last time because it enabled the state by default. But because we're making a change and we're making an update to this action group, We want to make sure that we're explicitly that we want this to be enabled. You can enable and disable action groups. And this might be something that's useful to do throughout the sort of life cycle of the management of the action group. But for us, we just want to keep it enabled. Then we can pass in some of the other details that are familiar to us by now. So we have our action group ID and agent ID they're set up and these are variables that we got from the environment variables of this current running environment. Let's paste in a couple more. So we've got the agent version which we've seen before. And then the group executer, which is going to be the Lambda function that we have in this environment, Then it comes to the big one, which is the function schema. So let's get ready for this. Now most of this function schema is going to be exactly the same as it was last time. So we're going to have our functions. So we're going to set those up or let's indent that properly. And that's going to be a list of functions. And we set up last time two different functions. And they were just I'm going to paste them in here. Customer ID, which is exactly as we had last time and send to support again, exactly as we had last time. But what we want to do here is we want to add in one more function that we can make use out of, which is going to be a function that we can use specifically in this particular example. And this one is going to get called and this is supported by the lambda function which is already deployed inside of this account. So it's called purchase search. And in terms of the lambda function, it works in exactly the same way as the other functions did in the last lesson. And so it's going to return something random again. So there's nothing special there. But the idea with this one is it can search for a purchase which has been made by a customer and get a reference like a like a purchase order, essentially, so that when we're escalating to support, we've actually found the actual instance of the thing that's been purchased. For example, maybe we want a refund for. So in the same way as we've done before. So we're going to add in a description. And in this case, I've got a fairly lengthy description which I'm going to add in here. And so let's just take a look through what we've got. So search for and get details of purchases made. Details can be used for raising support requests. I'm not saying it has to be, but they can be. You can confirm you have this data. For example, I found your purchase or I can't find your purchase, but other details are private information and must not be given to the user. So a decent step in the right direction, but we know that that's not completely foolproof. So next let's add in the parameters that we want for this. And the first parameter as we've had before is customer ID. So we're just saying we require the customer ID in order to be able to search for purchases that they've made. And the next is going to be product description. And here it is a description of the product to search for. So this the idea here is this is searching for and it needs to use the information that it has a logic that it's got in order to be able to find a candidate for what they purchase might have been. So that is product description. And then finally in this list, we have purchase date. And again, it's not actually the date, it's the purchase the date of purchase to start the search from. And it specifies a particular formatting for this date as well of year, month, day. So that's the format that we want. All of these are strings. All of these are required. And so that's everything that we need in order to update our action group. Essentially we're adding in one extra function there. The purchase such. But we had to include the original. Otherwise, it would have removed those. And just before we run this, let's go and say that we want to store this output. So we're going to store that and response as that. So update agent action group response. So that's useful. And then let's run that. Let's go and put our boilerplate code beneath so that we're going to wait for it to become ready. And of course it's already enabled. But we need it to wait. Okay, so we've made an update. The issue we have now is the trying to get the date, the purchase date for a given product, because the message we're going to try to deal with is this one here. So it's got a name, address, phone so it can find me. "I bought the mug ten weeks ago, and it's now broken. I want a refund." So we want to escalate this to support. We want to try and find the purchase that Mike made ten weeks ago. But we have our search here expecting or requesting that the date comes in, well, an actual date rather than a sort of natural language representation of date. So we've got a few things that we need to do here. How do we get the agent to figure out what the date was ten weeks ago, so that it can start to figure out the date of purchase and find the product? Find the purchase. Okay. So we're going to update our agent one more time. And in the same way that we did before, we're going to call Create Agent Action Group because we're creating another action group which is specifically going to be for Code Interpreter. So we can actually write and run some code itself. And that's configured in a special action group, which is actually much easier to create than the other one. So don't worry, there's not as many parameters in here. So let's go ahead and give it a name. So I'm going to call this the code interpreter action for the code interpreter action group. We're going to keep it enabled. think this is enabled by default, so we don't actually need this, but I'm going to put it in anyway. We're going to have in our agent ID and we're going to find our particular version which is draft. So that's all the sort of boilerplate kind of stuff. So how do we go about setting up for the code interpreter? Well, let's give ourselves plenty of space. Now, I'm only kidding. It doesn't. It's just one line of code here. And that's it. That's it right there. So the parent action group signature of Amazon code interpreter, because this is, sort of out of the box feature for Amazon Bedrock agents. So this is a special case of an action group specifically for code interpreter. So we've got that. Let's go and set ourselves up with a variable or a value for that to come back to. Let's do our boilerplate code that we're ready for this to return. So we're going to go ahead and grab the action group ID for this particular action group. And then we're going to wait for it to actually be a thing. So let's run that. So it's immediately enabled obviously very very fast for this particular one. But still worth having that just in case. So to enable we're just going to I'm just pasting it in at this point because we've seen this before. So we're going to prepare the agent and we're going to wait for it to become prepared. So we'll run that. And there we go. It's prepared. And then we're going to update the alias exactly the same situation on our agent. We call Update Agent Alias. And this time we're going to wait for it to finish. Updating and prepared. Okay. So really simple to set up. Let's just have a play. So we're going to set up our session ID, let's put a message back in here again so that we've got it and we can see it. So we're looking for it to try and figure out what ten weeks ago actually looked like. So let's run that. And then I'm going to go ahead and use my invoke agent and print. And we've enabled trace. We're just going to go for it this time. So we're sending in our message. We're sending in our session ID let's go for it. So let's run the cell and see what happens. So, "still want to refund." Let's have a look. So okay, let's process through this customer's request step by step. And so the first thing it does is it uses the code interpreter to figure out what ten weeks ago actually looked like. So it's written some code. It's executed that code. And it's come out with an output of this particular date, which happens to be ten weeks ago from the time when I'm recording this. So it's actually picked up the current date from the code execution environment. The code interpreter environment. Performed the Python code, and then it's returned with that. No errors, no timeout, which is what you want to see, of course. And then returned the actual date, which is fantastic. And so then it says okay based on the customer's message of the purchase date. So next up it's going and grabbing the ID because in order to do the, purchase search it needs the ID. So again this is the agentic workflow figuring this out for itself. And so it's come back with an ID. Yes. This is just a random number. But it's in principle my customer ID. And then it's doing the purchase search. So it's doing the search date. It's passed in the date in the correct format. It's then passed in my customer ID, and then it's put in a description of the product, which is just mug. So enough to be able to try and find the purchase order. And guess what? It found one. And it brought back the purchase ID And so with that, it can then go and send that to support. And here is the payload that it uses to send to support with all of that information in there, including the purchase ID in there as well as customer ID. And then finally it says, "I have processed your request and escalated it to our customer support team. They will review the details of your purchase and issue a refund if they might be eligible under our warranty policy." And so it's managed to do all of that work for us. All of that agentic flow, by figuring out what it needed to do. And bear in mind that all of this came from this natural language request, which was, I bought a mug ten weeks ago. It's broken. I want a refund. And. Okay. We can't actually leave it there, can we? We actually have to see this code that it's written. Let's have another go. We set up the same session ID, same message. But this time I'm going to call it without the helper function. Let's create ourselves the client. So we have our bedrock client here with the bedrock agent runtime client. So we set that up specifically. And then let's go and grab the kind of code that we had back in the very first lesson. So we're going to call the Bedrock agent runtime. We're going to invoke the agent passing in all the details. We're going to enable trace. Let's have that enabled and on true. And then well let's go ahead and grab out the event stream. From the completion. If you remember back to lesson one, and then I've just got this little chunk of code here. So this is basically just going to handle all that event stream stuff coming out. Try and do some, nice formatting to it. You'll see there's a lot of output, which is why we've been using the helper up until this point. But if we pass through it all, we'll find the Python code. Which code interpreter is written for us to calculate that date. So let's run this and well, here we go. And now you'll see all of the fine, data that we have available to us from trace. So it starts off and it's got its, very large prompt with all of the definitions of all of those functions in there. By the way, if you want to pause and take a look, then feel free to do that. Now let's carry on. It is deciding what it needs to do. It's going to go. And what's it doing here? It's, processing the customer request. So there's lots and lots of this. We're nowhere near the bottom. So code code interpreter invocation. Here we go. So it's decided, I guess, in this step above that it needs to try and figure out the date to approximately ten weeks ago. And so it writes this code. This code right here. There we go. That's our Python code, or that's its Python code that it has written. It's ephemeral code. It just writes it to get the answer. So it's importing, time and date. Oh, it's importing time and date and time. Delta. And then it's saying okay today equals that. So it's actually getting today's date. And then was it from there. Purchase date equals today. Minus time delta of ten weeks. Exactly what you'd need. And then it's getting that out. As what purchase date and then printing it at the end there. So the so the print of the output is actually what the large language model will see is the output from this code. So that's it. And once it's run, let's have a look at should. There we go. That's the code execution. The execution output. And that's it. Now, like, the code can vanish. We don't need it anymore. It's been written, it's been run. We've got our value. And off we go. All the way through all the rest of this, which is going to do all of those things. Such as, figuring out my ID and then sending the customer support issue off. That is why I've been using the helper function up until this point, because there's so much information in there. But I did need to show you, it using, and writing its own code. All right. That's the end of this lesson. I think this is super exciting. And I really enjoyed showing you this. In the next lesson, I'm going to talk about putting some guardrails around the agent.